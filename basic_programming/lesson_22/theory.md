# Lesson 22 

### OOP principals

1. **DRY - Don't Repeat Yourself**: Этот принцип направлен на сокращение повторения информации в программном коде. Основная идея заключается в том, чтобы каждый кусок знания или логики имел единственное, недвусмысленное представление в системе. Повторение кода увеличивает вероятность ошибок и усложняет процесс обновления и рефакторинга, так как изменения приходится вносить в несколько мест.

2. **SSOT - Single Source of Truth**: Этот принцип подчеркивает важность хранения всех данных в одном месте, чтобы избежать противоречий и путаницы. Когда информация распространяется через разные части системы, это упрощает ее поддержку и обновление. SSOT часто используется в базах данных и системах управления информацией.

3. **KISS - Keep It Simple, Stupid / Keep It Stupid Simple**: Этот принцип подчеркивает значимость простоты в дизайне и реализации. Сложные системы часто сложнее поддерживать, понимать и расширять. KISS предполагает, что проще всегда лучше и что сложность следует избегать, где это возможно.

4. **SOLID - это аббревиатура, описывающая пять принципов объектно-ориентированного программирования и дизайна**:
    - **Single Responsibility Principle (SRP)**: Каждый класс должен иметь только одну причину для изменения. Это означает, что класс должен выполнять только одну задачу или иметь только одну обязанность.
    - **Open-Closed Principle**: Сущности программного обеспечения (классы, модули, функции и т. д.) должны быть открыты для расширения, но закрыты для модификации. Это означает, что эти сущности можно расширять, не изменяя их существующий код.
    - **Liskov Substitution Principle (LSP)**: Объекты в программе должны быть заменяемы их подтипами без изменения правильности программы. Это связано с иерархией наследования и полиморфизмом.
    - **Interface Segregation Principle**: Не следует заставлять клиента реализовывать интерфейс, который он не использует. Это означает создание специализированных интерфейсов вместо одного универсального.
    - **Dependency Inversion Principle**: Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций. Это означает, что взаимодействие между высокоуровневыми и низкоуровневыми модулями должно осуществляться через абстракции, а не конкретные реализации.

    
### Структуры данных

1. Список

Список — это упорядоченный набор элементов, для каждого из которых хранится указатель на следующий (или для двусвязного списка и на следующий и на предыдущий) элементы списка. Иногда называется sequence. Элементы в списке могут повторяться. Одна  из важных особенностей списка - это наличие индекса у каждого элемента.

2. Стек

Стек — это коллекция, элементы которой получают по принципу «последний вошел, первый вышел» (Last-In-First-Out или LIFO). Это значит, что мы будем иметь доступ только к последнему добавленному элементу. Стек разрешает повтор одинаковых элементов.

Хорошим примером стека является стопка тарелок - верхняя тарелка была добавлена последняя в стопку (Last-In), но забрать ее можно будет первой (First-Out). Самая нижняя тарелка напротив была добавлена первой, но убрать ее можно будет только после удаления всех верхних тарелок. Получить доступ к тарелкам в середине стопки нельзя без удаления верхних тарелок.

Кстати, структура памяти стек организована по этому же принципу

5. Очередь

Очереди очень похожи на стеки. Они также не дают доступа к произвольному элементу, но, в отличие от стека, элементы помещаются (enqueue) и забираются (dequeue) с разных концов.  У очереди выделяют хвост и голову. Такой метод называется «первый вошел, первый вышел» (First-In-First-Out или FIFO). То есть забирать элементы из очереди мы будем в том же порядке, что и помещали. Как реальная очередь или конвейер. Очереди также разрешают повторы элементов.

4. Множество

Множество — неупорядоченный набор элементов, без повторов. Хорошим примером множества являются автомобили на парковке - каждое авто имеет уникальный номер, и нет необходимости их упорядочивать.



### Коллекции

Коллекции в Java - это фреймворк, предоставляющий архитектуру для хранения и манипулирования группами объектов и поддерживающие различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним.
Этот фреймворк является частью Java Collections Framework (JCF), включенного в Java SE с версии 1.2.
Он состоит из нескольких интерфейсов, реализаций и алгоритмов, которые помогают работать с группами объектов.

### Основные Интерфейсы

1. **Collection**: Это вершина иерархии коллекций, который определяет наименьший набор методов, реализуемых всеми коллекциями.

Методы интерфейса Collection:

    boolean add(E obj) - добавляет obj к вызывающей коллекции. Возвращает true, если obj был добавлен к коллекции.
    boolean addAll(Collection<? extends Е> с) - добавляет все элементы  к вызывающей коллекции. Возвращает true, если операция удалась (то есть все элементы добавлены). В противном случае возвращает false.
    void clear() - удаляет все элементы вызывающей коллекции. 
    boolean contains(Object obj) - возвращает true, если obj является элементом вызывающей коллекции. В противном случае возвращает false.
    boolean containsAll(Collection<?> с) - возвращает true, если вызывающая коллекция содержит все элементы с. В противном случае возвращает false.
    boolean equals(Object obj) - возвращает true, если вызывающая коллекция и obj эквивалентны. В противном случае возвращает false.
    int hashCode() - возвращает хешкод вызывающей коллекции. 
    boolean isEmpty() - возвращает true, если вызывающая коллекция пуста. В противном случае возвращает false. 
    Iterator<E> iterator() - возвращает итератор для вызывающей коллекции. 
    boolean remove(Object obj) - удаляет один экземпляр obj из вызывающей коллекции. Возвращает true, если элемент удален. В противном случае возвращает false.
    boolean removeAll(Collection<?> с) - удаляет все элементы из вызывающей коллекции. Возвращает truе, если в результате коллекция изменяется (то есть элементы удалены). В противном случае возвращает false. 
    boolean retainAll(Collection<?> с) - удаляет все элементы кроме входящих из вызывающей коллекции. Возвращает true, если в результате коллекция изменяется (то есть элементы удалены). В противном случае возвращает false. 
    int size() - возвращает количество элементов, содержащихся в коллекции. 
    Object[] toArray() - возвращает массив, содержащий все элементы вызывающей коллекции. Элементы массива являются копиями элементов коллекции.
    removeIf(Predicate<? super E> filter) - удаляет элементы из коллекции, соответствующие заданному условию.


2. **List**: Он расширяет Collection и представляет упорядоченную коллекцию (также называемую последовательностью). Элементы в списке могут быть доступны и управляемы по индексам. Примеры реализаций включают `ArrayList`, `LinkedList` и `Vector`.

3. **Set**: Этот интерфейс представляет набор уникальных элементов и также расширяет Collection. Он используется для хранения элементов, где порядок не важен, и каждый элемент уникален. Примеры реализаций включают `HashSet`, `LinkedHashSet` и `TreeSet`.

4. **Queue**: Этот интерфейс расширяет Collection и используется для удержания элементов перед обработкой. Он следует принципу FIFO (First-In-First-Out), хотя некоторые реализации, такие как `PriorityQueue`, могут использовать другие порядки.

5. **Deque**: Расширяет Queue и представляет двустороннюю очередь, где элементы могут быть добавлены или удалены с обоих концов.

### Основные Реализации

1. **ArrayList**: Это динамически расширяемый массив. Он позволяет быстрый доступ к элементам по индексу.

2. **LinkedList**: Это связанный список, который обеспечивает эффективное вставление и удаление.

3. **HashSet**: Это коллекция, использующая хэш-таблицу для хранения. Она обеспечивает быстрый доступ к элементам.

4. **TreeSet**: Это отсортированное множество, реализованное в виде красно-черного дерева.

5. **PriorityQueue**: Очередь с приоритетами, элементы из которой извлекаются в соответствии с их приоритетом.

### Особенности и Преимущества

- **Универсальность**: Коллекции могут содержать любые типы объектов и автоматически увеличиваются при необходимости.
- **Безопасность типов**: Java Collections Framework поддерживает обобщения, что позволяет обеспечить безопасность типов во время компиляции.
- **Производительность**: Наиболее используемые реализации, такие как `ArrayList` и `HashSet`, оптимизированы для высокой производительности.
- **Алгоритмы**: JCF предоставляет множество полезных алгоритмов, таких как сортировка и перемешивание.


### Интерфейс List в Java

Интерфейс `List` в Java представляет упорядоченную коллекцию (или последовательность) элементов. Он является одним из наиболее часто используемых интерфейсов в Java Collections Framework. 

Вот ключевые особенности и функции интерфейса `List`:

1. **Упорядоченная Коллекция**: Элементы в списке хранятся в определенном порядке. Элементы могут быть вставлены или доступны по индексу.

2. **Доступ к Элементам**: `List` предоставляет методы для получения, добавления, удаления и замены элементов по индексу.

3. **Допускает Дубликаты**: Элементы могут повторяться в списке. Каждый элемент может иметь один или несколько дубликатов.

4. **Итерация**: Интерфейс `List` предоставляет специальные итераторы, которые позволяют двунаправленную навигацию по списку.

5. **Методы `List`**: Включает методы, такие как `add()`, `remove()`, `get()`, `set()`, `indexOf()`, `lastIndexOf()`, и многие другие.

6. **Гибкость**: `List` может использоваться как массив с изменяемым размером, что позволяет легко добавлять и удалять элементы.

### Класс ArrayList

`ArrayList` - это одна из наиболее популярных реализаций интерфейса `List`. Вот основные характеристики и особенности класса `ArrayList`:

1. **Основан на Массиве**: `ArrayList` использует динамический массив для хранения элементов. Это позволяет быстро получать доступ к элементам по индексу.

2. **Динамическое Изменение Размера**: В отличие от обычных массивов, `ArrayList` может автоматически увеличивать свой размер при добавлении элементов.

3. **Производительность**: `ArrayList` предлагает быстрый доступ к элементам (операции чтения), но может быть медленнее при добавлении или удалении элементов из середины списка, так как это может потребовать сдвига элементов.

4. **Инициализация Емкости**: Можно инициализировать `ArrayList` с начальной емкостью, чтобы оптимизировать производительность.

5. **Null-элементы**: `ArrayList` допускает наличие `null` в качестве элементов.

6. **Синхронизация**: По умолчанию `ArrayList` не синхронизирован. Если нужна потокобезопасная версия, можно использовать `Collections.synchronizedList()`.

7. **Сериализация**: `ArrayList` поддерживает сериализацию, что позволяет передавать списки между различными частями программы или сохранять их для последующего использования.

### Использование ArrayList

`ArrayList` идеально подходит для сценариев, где основной операцией является доступ к элементам, а вставка и удаление элементов не являются основными операциями. Он широко используется в программах Java для хранения и обработки динамических наборов данных.