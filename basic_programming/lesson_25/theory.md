# Lesson 25

### `TreeSet`

Коллекция `TreeSet` в Java является частью Java Collection Framework. Она представляет собой упорядоченное множество, основанное на красно-черном дереве. 

Вот основные характеристики и особенности `TreeSet`:

1. **Упорядоченность элементов**: `TreeSet` автоматически сортирует элементы по возрастанию. Это достигается благодаря использованию красно-черного дерева, которое является сбалансированным двоичным деревом поиска.

2. **Уникальность**: Как и любое другое множество в Java, `TreeSet` содержит только уникальные элементы. Он не позволяет дубликаты.

3. **Реализация интерфейса `NavigableSet`**: `TreeSet` реализует `NavigableSet`, который расширяет `SortedSet` и предоставляет дополнительные методы для навигации по множеству.

4. **Параметризация (Generics)**: `TreeSet` может быть параметризован для работы с объектами определенного типа.

5. **Производительность**: Операции поиска, вставки и удаления в `TreeSet` выполняются за логарифмическое время относительно размера множества, что делает его эффективным для больших наборов данных.

6. **Компараторы**: По умолчанию `TreeSet` использует естественный порядок элементов. Однако можно определить собственный компаратор для управления порядком сортировки элементов.

7. **Null-элементы**: `TreeSet` не позволяет добавлять `null`-элементы, если используется естественный порядок сортировки. При использовании собственного компаратора возможность добавления `null` зависит от реализации компаратора.

8. **Потокобезопасность**: `TreeSet` не является потокобезопасным. Для использования в многопоточной среде необходимо предпринять дополнительные меры, такие как обертывание в `Collections.synchronizedSortedSet`.

`TreeSet` подходит для приложений, где требуется эффективное хранение уникальных элементов с быстрой возможностью поиска, вставки и удаления, а также при необходимости поддержания упорядоченности элементов.



### Итератор в Java

Итератор в Java является важным понятием, особенно в контексте коллекций. Он предоставляет способ обхода элементов коллекции без раскрытия её внутреннего представления. В Java итератор определяется интерфейсом `Iterator`, который входит в пакет `java.util`. Вот ключевые аспекты итераторов:

## Основные Методы

1. **`hasNext()`**: Этот метод возвращает `true`, если в коллекции есть ещё элементы для обхода. Он часто используется в условии цикла для проверки, остались ли элементы.

2. **`next()`**: Возвращает следующий элемент коллекции. Этот метод вызывается после `hasNext()` для получения элемента. Если элементов для возврата нет, метод бросает исключение `NoSuchElementException`.

3. **`remove()`**: Удаляет из коллекции последний элемент, возвращенный этим итератором (опциональная операция). Этот метод можно вызвать только один раз после каждого вызова `next()` и если коллекция поддерживает удаление элементов.

## Особенности

- **Универсальность**: Итераторы можно использовать с любыми коллекциями, такими как `List`, `Set`, `Map` и т.д.

- **Безопасность**: Итераторы позволяют безопасно удалять элементы из коллекции во время итерации, что напрямую через коллекцию делать нельзя, так как это может привести к `ConcurrentModificationException`.

- **Однонаправленность**: Итераторы, как правило, обеспечивают однонаправленный проход по коллекции (от начала к концу).

## Расширенные Итераторы

- **`ListIterator`**: Это расширение `Iterator`, предназначенное для списков. 
Оно поддерживает обход элементов в обоих направлениях (вперёд и назад), а также позволяет модифицировать элементы и получать индексы текущего элемента.

Данный итератор используется классами, реализующими интерфейс List, то есть классами LinkedList, ArrayList и др.

Интерфейс ListIterator расширяет интерфейс Iterator и определяет ряд дополнительных методов:

    void add(E obj): вставляет объект obj перед элементом, который должен быть возвращен следующим вызовом next()

    boolean hasNext(): возвращает true, если в коллекции имеется следующий элемент, иначе возвращает false

    boolean hasPrevious(): возвращает true, если в коллекции имеется предыдущий элемент, иначе возвращает false

    E next(): возвращает текущий элемент и переходит к следующему, если такого нет, то генерируется исключение NoSuchElementException

    E previous(): возвращает текущий элемент и переходит к предыдущему, если такого нет, то генерируется исключение NoSuchElementException

    int nextIndex(): возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка

    int previousIndex(): возвращает индекс предыдущего элемента. Если такого нет, то возвращается число -1

    void remove(): удаляет текущий элемент из списка. Таким образом, этот метод должен быть вызван после методов next() или previous(), иначе будет сгенерировано исключение IlligalStateException

    void set(E obj): присваивает текущему элементу, выбранному вызовом методов next() или previous(), ссылку на объект obj



- **`Spliterator`**: Введен в Java 8, этот итератор предназначен для параллельного обхода элементов, особенно полезен в контексте параллельных потоковых операций.

## Пример Использования

```java
List<String> list = Arrays.asList("apple", "banana", "cherry");
Iterator<String> it = list.iterator();

while (it.hasNext()) {
    String item = it.next();
    System.out.println(item);
    // Можно удалить элемент через it.remove();
}
```

## Использование с `for-each`

В Java 5 и новее, цикл `for-each` (улучшенный цикл `for`) предоставляет альтернативный способ обхода коллекций, который внутренне использует итераторы. Это делает код более читаемым и уменьшает вероятность ошибок.

```java
for(String item : list) {
    System.out.println(item);
}
```

Итераторы играют ключевую роль в обработке коллекций в Java, обеспечивая универсальный способ доступа и манипуляции данными в различных типах коллекций.



### Интерфейсы Comparable и Comparator

Ранее была рассмотрена работа коллекции `TreeSet`, типизированной объектами `String`. При добавлении новых элементов, `TreeSet` автоматически выполняет сортировку, размещая новый объект в правильном порядке. Со строками всё ясно, но что если использовать не строки, а собственные классы, например, класс `Person`:

```java
class Person{
    private String name;
    Person(String name){
        this.name = name;
    }
    String getName(){ return name; }
}
```

Если мы попытаемся типизировать объект `TreeSet` данным классом, то при добавлении объектов в `TreeSet` возникнет проблема: `TreeSet` не будет знать, как их сравнивать. Следующий код не будет работать:

```java
TreeSet<Person> people = new TreeSet<Person>();
people.add(new Person("Tom"));
```

При выполнении этого кода возникнет ошибка, указывающая на то, что объект `Person` не может быть преобразован к типу `java.lang.Comparable`.

Для того чтобы объекты `Person` можно было сравнивать и сортировать, они должны реализовывать интерфейс `Comparable<E>`. При реализации этого интерфейса он типизируется текущим классом. Применим его к классу `Person`:

```java
class Person implements Comparable<Person>{
    private String name;
    Person(String name){
        this.name = name;
    }
    String getName(){ return name; }

    public int compareTo(Person p){
        return name.compareTo(p.getName());
    }
}
```

Интерфейс `Comparable` содержит единственный метод `int compareTo(E item)`, который сравнивает текущий объект с объектом, переданным в качестве параметра. Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед параметром. Если метод вернет положительное число, то после. Если метод возвращает ноль, то объекты считаются равными.

В данном случае мы полагаемся на встроенный механизм сравнения у класса `String`, но можем определить и свою логику, например, сравнивать по длине имени:

```java
public int compareTo(Person p){
    return name.length() - p.getName().length();
}
```

Теперь мы можем типизировать `TreeSet` типом `Person` и добавлять в дерево соответствующие объекты:

```java
TreeSet<Person> people = new TreeSet<Person>();
people.add(new Person("Tom"));
```

### Интерфейс Comparator

Что если класс, который мы хотим использовать, не реализует интерфейс `Comparable`, или его реализация нас не устраивает? В таком случае можно использовать интерфейс `Comparator<E>`.

Интерфейс `Comparator` содержит ключевой метод `compare()`:

```java
public interface Comparator<E> {
    int compare(T a, T b);
    // остальные методы
}
```

Метод `compare` также возвращает числовое значение: если оно отрицательное, то объект `a` предшествует объекту `b`, иначе — наоборот. Если метод возвращает ноль, то объекты равны. Для применения интерфейса создаем класс компаратора, реализующий этот интерфейс:

```java
class PersonComparator implements Comparator<Person>{
    public int compare(Person a, Person b){
        return a.getName().compareTo(b.getName());
    }
}
```

Здесь проводим сравнение по строкам. Теперь используем класс компаратора для создания объекта `TreeSet`:

```java
PersonComparator pcomp = new PersonComparator();
TreeSet<Person> people = new TreeSet<Person>(pcomp);
people.add(new Person("Tom"));
people.add(new Person("Nick"));
people.add(new Person("Alice"));
people.add(new Person("Bill"));
for(Person p : people){
    System.out

.println(p.getName());
}
```

Для создания `TreeSet` здесь используется конструктор, который в качестве параметра принимает компаратор. Теперь, независимо от того, реализован ли в классе `Person` интерфейс `Comparable`, логика сравнения и сортировки будет определена в классе компаратора.

### Сортировка по нескольким критериям

Начиная с JDK 8, в механизм работы компараторов были внесены дополнения, позволяющие применять сразу несколько компараторов по принципу приоритета. Например, изменим класс `Person` следующим образом:

```java
class Person{
    private String name;
    private int age;
    public Person(String n, int a){
        name = n;
        age = a;
    }
    String getName(){ return name; }
    int getAge(){ return age; }
}
```

Здесь добавлено поле для хранения возраста пользователя. И, допустим, нам надо отсортировать пользователей по имени и по возрасту. Для этого определим два компаратора:

```java
class PersonNameComparator implements Comparator<Person>{
    public int compare(Person a, Person b){
        return a.getName().compareTo(b.getName());
    }
}
class PersonAgeComparator implements Comparator<Person>{
    public int compare(Person a, Person b){
        if(a.getAge() > b.getAge())
            return 1;
        else if(a.getAge() < b.getAge())
            return -1;
        else
            return 0;
    }
}
```

Интерфейс компаратора определяет метод по умолчанию `thenComparing`, который позволяет использовать цепочки компараторов для сортировки набора:

```java
Comparator<Person> pcomp = new PersonNameComparator().thenComparing(new PersonAgeComparator());
TreeSet<Person> people = new TreeSet(pcomp);
people.add(new Person("Tom", 23));
people.add(new Person("Nick", 34));
people.add(new Person("Tom", 10));
people.add(new Person("Bill", 14));

for(Person p : people){
    System.out.println(p.getName() + " " + p.getAge());
}
```

Консольный вывод:

```
Bill 14
Nick 34
Tom 10
Tom 23
```

В этом случае сначала применяется сортировка по имени, а затем по возрасту.

