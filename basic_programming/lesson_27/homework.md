## Домашнее задание 

Теория графов - это раздел математики и информатики, который изучает свойства и структуры, состоящие из узлов (вершин) и рёбер, соединяющих эти узлы. Давайте более подробно рассмотрим основные понятия и типы графов.

### Основные Понятия

1. **Узлы (Вершины)**: Это фундаментальные объекты в графе, которые могут представлять различные сущности, в зависимости от контекста применения графа (например, города в карте, компьютеры в сети).

2. **Рёбра**: Это соединения между парами узлов. Рёбра могут быть направленными или ненаправленными. Направленное ребро указывает на то, что связь между узлами имеет определённое направление (например, односторонняя дорога), в то время как ненаправленное ребро представляет двустороннюю связь.

3. **Веса Рёбер**: Во многих графах рёбрам могут быть присвоены веса, что позволяет представлять такие вещи, как расстояние, стоимость, время и другие количественные характеристики.

### Типы Графов

1. **Ненаправленные Графы**: Рёбра не имеют направления. Связь между узлами взаимная.

2. **Направленные Графы (Диграфы)**: Рёбра имеют направление. Связь между узлами односторонняя.

3. **Взвешенные Графы**: Графы, где каждому ребру присвоен вес или стоимость.

4. **Деревья**: Это связные ненаправленные графы без циклов. Деревья имеют корневой узел и иерархическую структуру.

5. **Ациклические Направленные Графы (DAG)**: Направленные графы без циклов. Часто используются для представления структур с зависимостями (например, деревья решений).

6. **Полные Графы**: Графы, в которых каждая пара узлов соединена ребром.

7. **Разреженные и Плотные Графы**: В разреженных графах количество рёбер значительно меньше, чем максимально возможное, в то время как в плотных графах количество рёбер близко к максимально возможному.

### Применение Графов

Графы применяются в самых разных областях, таких как:

- **Компьютерные Сети**: Для представления сетевой инфраструктуры.
- **Социальные Сети**: Для анализа связей между людьми.
- **Географические Карты**: Для представления и нахождения кратчайших путей.
- **Оптимизация**: В задачах поиска оптимальных маршрутов и расписаний.
- **Биология и Химия**: Для моделирования молекулярных структур и биологических сетей.

### Алгоритмы на Графах

Существует множество алгоритмов для работы с графами, включая поиск в ширину (BFS), поиск в глубину (DFS), алгоритмы поиска кратчайшего пути (например, Дейкстра, Беллмана-Форда), алгоритмы для нахождения минимального остовного дерева (например, Прима, Краскала) и многие другие.

В Java графы могут быть реализованы различными способами, в зависимости от конкретных требований и характеристик графа, таких как направленный/ненаправленный, взвешенный/невзвешенный, циклический/ациклический и т.д.

### Основные Способы Реализации Графов:

#### 1. Матрица Смежности

Это один из самых простых способов представления графа. Граф представляется в виде двумерного массива, где каждый элемент `[i][j]` массива представляет наличие (или отсутствие) ребра между вершинами `i` и `j`. Для взвешенных графов, вес ребра хранится в соответствующей ячейке.

**Пример реализации:**

```java
public class Graph {
    private final int V; // Количество вершин
    private boolean[][] adjMatrix; // Матрица смежности

    // Конструктор
    public Graph(int V) {
        this.V = V;
        adjMatrix = new boolean[V][V];
    }

    // Добавление ребра
    public void addEdge(int i, int j) {
        adjMatrix[i][j] = true;
        adjMatrix[j][i] = true; // Для ненаправленного графа
    }

    // Проверка наличия ребра
    public boolean isEdge(int i, int j) {
        return adjMatrix[i][j];
    }
}
```

#### 2. Списки Смежности

Это еще один популярный способ представления графов, особенно эффективный для разреженных графов. Здесь каждая вершина графа ассоциируется со списком или множеством всех смежных вершин.

**Пример реализации:**

```java
public class Graph {
    private int V; // Количество вершин
    private List<List<Integer>> adjLists; // Список смежности

    // Конструктор
    public Graph(int V) {
        this.V = V;
        adjLists = new ArrayList<>(V);
        for (int i = 0; i < V; i++) {
            adjLists.add(new ArrayList<>());
        }
    }

    // Добавление ребра
    public void addEdge(int src, int dest) {
        adjLists.get(src).add(dest);
        adjLists.get(dest).add(src); // Для ненаправленного графа
    }
}
```

#### 3. Ребра как Объекты

В этом подходе каждое ребро графа представляется в виде объекта. Этот подход особенно удобен для взвешенных графов, где каждое ребро имеет свой вес.

**Пример реализации:**

```java
public class Graph {
    private static class Edge {
        int src, dest, weight;
        Edge(int src, int dest, int weight) {
            this.src = src;
            this.dest = dest;
            this.weight = weight;
        }
    }

    private List<Edge> edges;

    public Graph() {
        edges = new ArrayList<>();
    }

    public void addEdge(int src, int dest, int weight) {
        edges.add(new Edge(src, dest, weight));
    }
}
```

### Выбор Подхода

Выбор подхода зависит от специфики задачи:

- Матрица смежности удобна для плотных г

рафов и когда часто нужно проверять наличие ребра между двумя вершинами.
- Списки смежности эффективнее для разреженных графов и удобны для итерирования по смежным вершинам.
- Ребра как объекты предпочтительны, когда графы взвешены, и важны детали каждого ребра.

### Библиотеки для Работы с Графами

В Java также доступны специализированные библиотеки для работы с графами, такие как JGraphT, которые предоставляют более богатый функционал и оптимизированные алгоритмы для работы с графами.

Теория графов представляет собой обширную и фундаментальную область, находящую широкое применение в науке и технике.



### Деревья (Tree)

Деревья - это иерархическая структура данных, важная для представления отношений между элементами. Дерево состоит из узлов, соединённых рёбрами. Давайте более подробно рассмотрим основные термины, виды деревьев и их структуры.

### Основные Термины

1. **Узел (Node)**: Основная единица дерева. Узел может содержать данные и ссылки на другие узлы.

2. **Корень (Root)**: Узел на вершине дерева, не имеющий родителей.

3. **Потомок (Child)**: Узел, который является непосредственным продолжением другого узла.

4. **Родитель (Parent)**: Узел, который имеет ссылку на одного или нескольких потомков.

5. **Лист (Leaf)**: Узел без потомков.

6. **Высота дерева (Height)**: Максимальное количество уровней в дереве. Высота узла - количество шагов от узла до самого дальнего листа.

7. **Глубина узла (Depth)**: Количество шагов от корня до данного узла.

8. **Поддерево (Subtree)**: Любой узел в дереве вместе со всеми его потомками.

### Виды Деревьев

1. **Бинарное Дерево**: Каждый узел имеет максимум два потомка.

2. **Бинарное Дерево Поиска (BST)**: Дерево, в котором все левые потомки каждого узла имеют значение меньше, а правые потомки - больше значения этого узла.

3. **AVL-дерево**: Самобалансирующееся бинарное дерево поиска, где высота двух поддеревьев каждого узла отличается не более чем на один.

4. **Красно-чёрное дерево**: Ещё один тип самобалансирующегося бинарного дерева поиска, обеспечивающий эффективное добавление, удаление и поиск элементов.

5. **B-дерево и B+ дерево**: Оптимизированы для чтения и записи на физические носители и часто используются в базах данных.

6. **Трие (Trie)**: Специализированное дерево, используемое в основном для хранения строк. В каждом узле хранится один символ, и пути от корня к листу представляют строки.

### Примеры Кода

#### Пример Бинарного Дерева

```java
class Node {
    int key;
    Node left, right;

    public Node(int item) {
        key = item;
        left = right = null;
    }
}

class BinaryTree {
    Node root;

    BinaryTree() {
        root = null;
    }

    // Методы для работы с деревом (например, добавление, поиск)
}
```

#### Пример Бинарного Дерева Поиска (BST)

```java
class Node {
    int key;
    Node left, right;

    public Node(int value) {
        key = value;
        left = right = null;
    }
}

class BinarySearchTree {
    Node root;

    BinarySearchTree() {
        root = null;
    }

    void insert(int key) {
        root = insertRec(root, key);
    }

    Node insertRec(Node root, int key) {
        if (root == null) {
            root = new Node(key);
            return root;
        }
        if (key < root.key) {
            root.left = insertRec(root.left, key);
        } else

 if (key > root.key) {
            root.right = insertRec(root.right, key);
        }
        return root;
    }

    // Методы для поиска и удаления
}
```

### Заключение

Деревья - мощная структура данных, применяемая во многих областях, включая алгоритмы, базы данных и обработку данных. Они помогают организовать данные иерархически, обеспечивая эффективный доступ, поиск и модификацию данных.



### Нотация "О большое" (Big O notation)

Нотация "О большое" (Big O notation) является математической концепцией, используемой в информатике для описания асимптотической сложности алгоритмов. Это способ описания ограничения сверху на время выполнения алгоритма в худшем случае, выраженное как функция от размера входных данных.

### Основные Понятия

1. **Асимптотическая Сложность**: Это характеризует поведение алгоритма при увеличении размера входных данных. Нотация "О большое" описывает верхний предел времени выполнения алгоритма в худшем случае.

2. **"О" относится к "Order of"**: Это означает "порядок" или "скорость роста" времени выполнения алгоритма.

3. **Зависимость от Входных Данных**: Асимптотическая сложность алгоритма зависит от размера входных данных (например, количество элементов в массиве).

### Примеры

1. **O(1) - Константная Сложность**: Время выполнения алгоритма не зависит от размера входных данных.

   ```java
   void example(int[] array) {
       System.out.println(array[0]);
   }
   ```

2. **O(n) - Линейная Сложность**: Время выполнения алгоритма линейно зависит от размера входных данных.

   ```java
   void example(int[] array) {
       for (int i = 0; i < array.length; i++) {
           System.out.println(array[i]);
       }
   }
   ```

3. **O(n²) - Квадратичная Сложность**: Время выполнения алгоритма пропорционально квадрату размера входных данных. Часто встречается в алгоритмах с двумя вложенными циклами.

   ```java
   void example(int[] array) {
       for (int i = 0; i < array.length; i++) {
           for (int j = 0; j < array.length; j++) {
               System.out.println(array[i] + "," + array[j]);
           }
       }
   }
   ```

4. **O(log n) - Логарифмическая Сложность**: Время выполнения алгоритма увеличивается логарифмически в зависимости от размера входных данных. Типичный пример - бинарный поиск.

   ```java
   void binarySearch(int[] array, int key) {
       int low = 0;
       int high = array.length - 1;
       while (low <= high) {
           int mid = low + (high - low) / 2;
           if (array[mid] == key) {
               return mid;
           }
           if (array[mid] < key) {
               low = mid + 1;
           } else {
               high = mid - 1;
           }
       }
       return -1;
   }
   ```

### Зачем Это Важно

Понимание нотации "О большое" важно для:

- Оценки производительности алгоритмов.
- Выбора наиболее подходящих алгоритмов для конкретных задач и условий.
- Понимания потенциальных узких мест в коде, особенно при работе с большими объемами данных.

Это ключевой инструмент, позволяющий разработчикам принимать обоснованные решения при проектировании алгоритмов и структур данных.


### Static и final

В Java, ключевые слова `static` и `final` имеют разные назначения и применения, хотя оба они относятся к управлению доступом и поведением переменных, методов и классов.

### 1. Static

Ключевое слово `static` применяется к переменным, методам и блокам кода и используется для создания членов класса, которые могут быть доступны без создания экземпляра класса.

#### Static Переменные

- Static переменные также известны как "переменные класса". Они общие для всех экземпляров класса.
- Все экземпляры класса имеют доступ к одной и той же статической переменной и изменения одним экземпляром видны всем остальным.

```java
class ExampleClass {
    static int staticVar = 5;
}
```

В этом примере, `staticVar` можно изменять через любой экземпляр `ExampleClass`, или же напрямую через имя класса (`ExampleClass.staticVar`).

#### Static Методы

- Static методы принадлежат классу, а не объекту.
- Они могут быть вызваны без создания экземпляра класса.
- Не могут обращаться к нестатическим переменным и методам напрямую и не могут использовать `this` или `super`.

```java
class ExampleClass {
    static void staticMethod() {
        System.out.println("Это статический метод.");
    }
}

ExampleClass.staticMethod(); // Вызов без создания объекта
```

#### Static Блоки

- Static блоки используются для инициализации статических переменных.
- Блок выполняется, когда класс загружается в память.

```java
class ExampleClass {
    static int staticVar;
    
    static {
        staticVar = 10;
        System.out.println("Static блок инициализации.");
    }
}
```

### 2. Final

Ключевое слово `final` применяется к переменным, методам и классам и служит для обозначения их неизменяемости.

#### Final Переменные

- Final переменные можно инициализировать только один раз.
- После присвоения значения, оно не может быть изменено.

```java
class ExampleClass {
    final int finalVar = 10;
    
    void someMethod() {
        finalVar = 15; // Ошибка компиляции, так как finalVar уже инициализирована
    }
}
```

#### Final Методы

- Final методы не могут быть переопределены в подклассах.
- Это полезно для предотвращения изменения поведения метода в наследуемых классах.

```java
class ExampleClass {
    final void finalMethod() {
        System.out.println("Это final метод.");
    }
}

class SubClass extends ExampleClass {
    void finalMethod() { // Ошибка компиляции
        System.out.println("Попытка переопределить.");
    }
}
```

#### Final Классы

- Final классы не могут быть унаследованы.
- Это полезно для предотвращения дальнейшего наследования и изменения функциональности класса.

```java
final class ExampleClass {
    // ...
}

class SubClass extends ExampleClass { // Ошибка компиляции
    // ...
}
```

### Заключение

`static` и `final` играют важную роль в управлении структурой и поведением классов и объектов в Java. `static` обеспечивает общий доступ к переменным и методам класса, в то время как `final` обеспечивает их неизменяемость и защиту от переопределения или наследования.

