# Lesson 26

Конечно, давайте рассмотрим более подробно каждую из этих коллекций и их ключевые методы с примерами кода.

### 1. Queue (Очередь)

**Описание**: `Queue` поддерживает FIFO (First-In-First-Out) порядок. Это означает, что элементы обрабатываются в порядке их добавления.

**Основные методы**:

- **`add(e)`**: Добавляет элемент в конец очереди. Генерирует исключение, если добавление невозможно.
- **`offer(e)`**: Тоже добавляет элемент в конец очереди, но возвращает `false`, если добавление невозможно.
- **`remove()`**: Удаляет и возвращает элемент из начала очереди. Генерирует исключение, если очередь пуста.
- **`poll()`**: Тоже удаляет и возвращает элемент из начала очереди, но возвращает `null`, если очередь пуста.
- **`element()`**: Возвращает, но не удаляет элемент из начала очереди. Генерирует исключение, если очередь пуста.
- **`peek()`**: Тоже возвращает, но не удаляет элемент из начала очереди, возвращая `null`, если очередь пуста.

**Пример кода**:

```java
Queue<Integer> queue = new LinkedList<>();
queue.add(1); // Добавляет элемент в очередь
queue.offer(2); // Тоже добавляет элемент
System.out.println(queue.peek()); // Возвращает 1 (первый элемент)
System.out.println(queue.poll()); // Удаляет и возвращает 1
System.out.println(queue.remove()); // Удаляет и возвращает 2
```

### 2. Deque (Двусторонняя очередь)

**Описание**: `Deque` расширяет `Queue`, позволяя работать с элементами как с начала, так и с конца очереди.

**Основные методы**:

- **`addFirst(e)` / `offerFirst(e)`**: Добавляют элемент в начало очереди.
- **`addLast(e)` / `offerLast(e)`**: Добавляют элемент в конец очереди.
- **`removeFirst()` / `pollFirst()`**: Удаляют и возвращают первый элемент очереди.
- **`removeLast()` / `pollLast()`**: Удаляют и возвращают последний элемент очереди.
- **`getFirst()` / `peekFirst()`**: Возвращают, но не удаляют первый элемент.
- **`getLast()` / `peekLast()`**: Возвращают, но не удаляют последний элемент.

**Пример кода**:

```java
Deque<Integer> deque = new ArrayDeque<>();
deque.addFirst(1); // Добавляет 1 в начало
deque.addLast(2); // Добавляет 2 в конец
System.out.println(deque.getFirst()); // Возвращает 1
System.out.println(deque.getLast()); // Возвращает 2
System.out.println(deque.pollFirst()); // Удаляет и возвращает 1
System.out.println(deque.pollLast()); // Удаляет и возвращает 2
```

### 3. Stack (Стек)

**Описание**: `Stack` реализует LIFO (Last-In-First-Out) порядок. Элементы добавляются и удаляются с одного и того же конца.

**Основные методы**:

- **`push(e)`**: Добавляет элемент на вершину стека.
- **`pop()`**: Удаляет и возвращает верхний элемент стека.
- **`peek()`**: Возвращает верхний элемент стека, не удаляя его.

**Пример кода**:

```java
Stack<Integer> stack = new Stack<>();
stack.push(1); // Добавляет 1
stack.push(2); // Добавляет 2
System.out.println(stack.peek()); // Возвращает 2
System.out.println

(stack.pop()); // Удаляет и возвращает 2
System.out.println(stack.pop()); // Удаляет и возвращает 1
```

### 4. PriorityQueue (Очередь с приоритетом)

**Описание**: `PriorityQueue` упорядочивает элементы в соответствии с их приоритетом.

**Основные методы**:

- **`add(e)` / `offer(e)`**: Добавляют элемент в очередь с приоритетом.
- **`remove()` / `poll()`**: Удаляют и возвращают элемент с наивысшим приоритетом.
- **`peek()`**: Возвращает элемент с наивысшим приоритетом, не удаляя его.

**Пример кода**:

```java
PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();
priorityQueue.add(3);
priorityQueue.add(1);
priorityQueue.add(2);
System.out.println(priorityQueue.peek()); // Возвращает 1
System.out.println(priorityQueue.poll()); // Удаляет и возвращает 1
System.out.println(priorityQueue.poll()); // Удаляет и возвращает 2
```

Эти коллекции предоставляют гибкие и мощные структуры данных для решения различных алгоритмических задач в Java.


### hashCode() и риски его неправильной реализации
 
Правильная реализация метода `hashCode()` в Java является критически важной, особенно при использовании коллекций, основанных на хеш-таблицах, таких как `HashSet`. Неправильная реализация `hashCode()` может привести к ряду проблем в работе таких коллекций. Давайте рассмотрим пример неправильной работы `hashCode()` и его последствия.

### Пример Неправильной Реализации `hashCode()`

Представим, что у нас есть класс `Person`, и мы хотим использовать объекты этого класса в `HashSet`. Класс `Person` имеет два поля: `name` и `age`.

```java
public class Person {
    private String name;
    private int age;

    // Конструкторы, геттеры и сеттеры здесь...

    @Override
    public int hashCode() {
        return 31; // Неправильная реализация, возвращает константу
    }

    @Override
    public boolean equals(Object obj) {
        // Проверка и сравнение полей name и age
    }
}
```

### Проблемы и Последствия

1. **Плохая Производительность**: Поскольку `hashCode()` всегда возвращает одно и то же значение, все объекты `Person` будут помещаться в один и тот же "bucket" внутри `HashSet`. Это приведет к значительному увеличению времени доступа к элементам, так как вместо быстрой операции хеширования `HashSet` будет вынужден пробегать по всем элементам в "bucket", используя метод `equals()` для сравнения, что снижает эффективность до уровня обычного списка.

2. **Нарушение Контракта между `hashCode()` и `equals()`**: Согласно контракту Java, если два объекта считаются равными с помощью метода `equals(Object)`, то вызов `hashCode()` для этих объектов должен возвращать одно и то же значение. Однако, если `hashCode()` реализован неверно и возвращает разные значения для объектов, которые считаются равными, это приведет к тому, что `HashSet` (или любая другая хеш-основанная коллекция) не сможет корректно определить, находится ли объект уже в коллекции.

3. **Невозможность Найти Объекты**: Если метод `hashCode()` объекта изменяется после того, как объект был добавлен в `HashSet`, это может привести к тому, что при последующих попытках найти этот объект в коллекции, он не будет найден, даже если он физически присутствует в коллекции.

### Лучшие Практики

- **Консистентность**: Убедитесь, что `hashCode()` возвращает одинаковые значения для объектов, которые считаются равными с помощью `equals()`.
- **Использование Полей Объекта**: В идеале `hashCode()` должен учитывать все значимые поля объекта. Например, можно комбинировать хеши отдельных полей, используя простые арифметические операции или `Objects.hash()`.
- **Неизменность**: Не используйте изменяемые поля объекта для расчета `hashCode()`, если есть вероятность, что эти поля изменятся, в то время как объект находится в хеш-основанной коллекции.

Правильная реализация `hashCode()` обеспечивает эффективную работу хеш-основанных коллекций и предотвращает неожиданные ошибки и недостатки производительности.