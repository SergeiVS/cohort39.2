# Lesson 20 


Большая часть классов приложения связаны между собой. В этом разделе рассмотрим какие бывают отношения между классами в Java.
1. IS-A отношения

В ООП принцип IS-A основан на наследовании классов или реализации интерфейсов. Например, если класс HeavyBox наследует Box, мы говорим, что HeavyBox является Box (HeavyBox IS-A Box). Или другой пример - класс Lorry расширяет класс Car. В этом случае Lorry IS-A Car.

То же самое относится и к реализации интерфейсов. Если класс Transport реализует интерфейс Moveable, то они находятся в отношении Transport IS-A Moveable.
2. HAS-A отношения

HAS-A отношения основаны на использовании. Выделяют три варианта отношения HAS-A: ассоциация, агрегация и композиция.

Начнем с ассоциации. В этих отношениях объекты двух классов могут ссылаться друг на друга. Например, класс Horse HAS-A Halter если код в классе Horse содержит ссылку на экземпляр класса Halter:
Ассоциация

```java

public class Halter {}

public class Horse{
private Halter halter;
}

```

Агрегация и композиция являются частными случаями ассоциации. Агрегация - отношение когда один объект является частью другого. А композиция - еще более тесная связь, когда объект не только является частью другого объекта, но и вообще не может принадлежать другому объекту. Разница будет понятна при рассмотрении реализации этих отношений.
Агрегация

Объект класса Halter создается извне Horse и передается в конструктор для установления связи. Если объект класса Horse будет удален, объект класса Halter может и дальше использоваться, если, конечно, на него останется ссылка:

```java
public class Horse {
private Halter halter;

    public Horse(Halter halter) {
        this.halter = halter;
    }
}

```

Композиция

Теперь посмотрим на реализацию композиции. Объект класса Halter создается в конструкторе, что означает более тесную связь между объектами. Объект класса Halter не может существовать без создавшего его объекта Horse:

```java
public class Horse {
private Halter halter;

    public Horse() {
        this.halter = new Halter();
    }
}

```

Вопросы
### Агрегация в Объектно-Ориентированном Программировании

#### Определение Агрегации
Агрегация — это принцип объектно-ориентированного программирования, который описывает отношение "имеет-а" (has-a) между объектами. 
В контексте агрегации, один объект (агрегирующий объект) содержит или использует другие объекты, 
но эти объекты могут существовать независимо от агрегирующего объекта. 
Это отношение обозначает, что в то время как объекты могут быть связаны, они не зависят друг от друга жизненно.

#### Особенности Агрегации
1. **Независимость Компонентов**: Компоненты (агрегируемые объекты) могут существовать независимо от агрегирующего объекта.
2. **Слабое Владение**: Агрегирующий объект не контролирует жизненный цикл агрегируемых объектов.

#### Пример Агрегации
Рассмотрим класс `Автомобиль` и класс `Двигатель`. Автомобиль имеет двигатель, но двигатель может существовать и вне автомобиля.

```java
public class Двигатель {
    // характеристики двигателя
}

public class Автомобиль {
    private Двигатель двигатель; // Агрегация

    public Автомобиль(Двигатель двигатель) {
        this.двигатель = двигатель;
    }
}
```

В этом примере, `Автомобиль` агрегирует `Двигатель`. 
Двигатель, предоставляемый в конструкторе `Автомобиля`, может существовать независимо от конкретного автомобиля.

#### Отличие Агрегации от Композиции
Агрегация часто путают с композицией, однако между ними есть ключевое различие:

- **Композиция** предполагает более сильную связь, где компоненты не могут существовать независимо от целого (например, комнаты не могут существовать без дома).
- **Агрегация** подразумевает более слабую связь и независимость компонентов (например, автомобиль и двигатель).

#### Практическое Применение Агрегации
Агрегация полезна в ситуациях, где необходимо собрать несколько объектов вместе для выполнения определённой задачи, 
но при этом сохранить их независимость. 
Это облегчает повторное использование кода и обеспечивает гибкость в управлении различными частями системы.

#### Заключение
Агрегация в объектно-ориентированном программировании представляет собой важный способ моделирования отношений между объектами, позволяющий создавать сложные системы из более простых и независимых компонентов. 
Это улучшает модульность и гибкость кода, делая его более понятным и удобным в обслуживании.


### Композиция в Объектно-Ориентированном Программировании

#### Определение Композиции
Композиция — это одна из форм ассоциации, которая представляет собой строгую зависимость между двумя объектами. В отношении композиции, когда образующий (композитный) объект уничтожается, его составные части также уничтожаются. Это отношение обычно описывается как "часть-целое" (part-whole).

#### Особенности Композиции
1. **Сильная Зависимость**: В отношении композиции, составные части не могут существовать самостоятельно от целого.
2. **Жизненный Цикл**: Жизненный цикл составных частей строго связан с жизненным циклом композитного объекта.

#### Пример Композиции
Рассмотрим класс `Дом` и класс `Комната`. Комната является частью дома и не может существовать отдельно от него.

```java
public class Комната {
    // детали комнаты
}

public class Дом {
    private List<Комната> комнаты = new ArrayList<>();

    public Дом() {
        комнаты.add(new Комната()); // Комната создается в контексте дома
    }
    // Методы для управления комнатами
}
```

В этом примере, `Дом` содержит несколько объектов `Комната`. Комнаты существуют только в контексте `Дома` и не имеют независимого существования.

#### Отличие Композиции от Агрегации
Композиция отличается от агрегации более строгой зависимостью. В агрегации составные части могут существовать независимо от агрегирующего объекта, тогда как в композиции они не могут.

#### Применение Композиции
Композиция часто используется для представления физических или логических целостностей, где части не могут функционировать отдельно от целого. Это обеспечивает строгую инкапсуляцию, гарантируя, что составные части не могут быть доступны или использованы отдельно.

#### Преимущества Композиции
- **Структурированное Управление**: Обеспечивает структурированное управление жизненным циклом составных частей.
- **Ясность Отношений**: Чётко определяет отношения между объектами, делая код более понятным и легким для поддержки.
- **Безопасность**: Защищает составные части от неправильного использования вне контекста целого.

#### Заключение
Композиция в ООП представляет собой сильное отношение "часть-целое", которое используется для моделирования строгих зависимостей между объектами. Это ключевой элемент в создании структурированных, инкапсулированных и легко управляемых программных систем.


### Внутренние Классы в Java

#### Определение Внутренних Классов
Внутренние классы в Java – это классы, объявленные внутри других классов. Они предоставляют мощный механизм инкапсуляции, позволяя группировать классы, которые логически связаны между собой, внутри одного внешнего класса.

#### Типы Внутренних Классов
1. **Неcтатические Вложенные Классы (Inner Classes)**: Они связаны с экземпляром внешнего класса и имеют доступ к его членам, даже если они объявлены как `private`.
2. **Статические Вложенные Классы (Static Nested Classes)**: Они не имеют ссылки на экземпляр внешнего класса и используются, когда вложенный класс должен работать независимо от внешнего класса.
3. **Локальные Классы**: Классы, объявленные внутри блока кода (например, внутри метода).
4. **Анонимные Классы**: Классы без названия, объявляемые и инстанциируемые в одном выражении. Они обычно используются для расширения существующих классов или реализации интерфейсов на лету.

#### Пример Нестатического Вложенного Класса
```java
public class ВнешнийКласс {
    private String данные = "Внешний";

    class ВнутреннийКласс {
        void показать() {
            System.out.println("Данные: " + данные); // Доступ к членам внешнего класса
        }
    }

    public void создатьВнутренний() {
        ВнутреннийКласс внутренний = new ВнутреннийКласс();
        внутренний.показать();
    }
}
```

#### Пример Статического Вложенного Класса
```java
public class ВнешнийКласс {
    static class СтатическийВложенныйКласс {
        void показать() {
            System.out.println("Статический вложенный класс");
        }
    }
}

// Создание экземпляра статического вложенного класса
ВнешнийКласс.СтатическийВложенныйКласс объект = new ВнешнийКласс.СтатическийВложенныйКласс();
```

#### Применение Внутренних Классов
1. **Инкапсуляция**: Внутренние классы могут скрывать сложную реализацию от внешнего мира.
2. **Организация Кода**: Они помогают лучше организовать код, сгруппировав вместе связанные элементы.
3. **Доступ к Частным Членам**: Внутренние классы имеют доступ к частным членам внешнего класса и могут взаимодействовать с ними.

#### Особенности
- Внутренние классы могут увеличить связанность кода и его сложность.
- Они полезны для создания слушателей событий и обработчиков, а также для реализации многоуровневых структур данных.

#### Заключение
Внутренние классы в Java представляют собой мощный инструмент для более глубокой инкапсуляции и лучшей организации кода. 
Они позволяют логически сгруппировать классы и обеспечить более тесную связь между внешними и внутренними классами, улучшая читаемость и поддерживаемость кода.