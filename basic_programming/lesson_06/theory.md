# Lesson 05

### 1. String и его основные методы
Для работы со строками в Java существует класс String. 
И для объявления новой строки можно использовать один из нескольких способов.
   String str1 = "Java";
   String str2 = new String(); // пустая строка
   String str3 = new String("Java");

Важной особенностью строк в Java является их неизменяемость. 
Это значит, что в строке нельзя попросту изменить какой-либо символ и получить другую строку. 
Все строки создаются и существуют в неизменном виде. 
А переменные str1, str2 и str3 следует воспринимать лишь как ссылки на эти строки.

У класса String есть несколько полезных методов:


length() - возвращает число символов в строке (длину строки)
isEmpty() - определяет является ли строка пустой
concat() - объединяет строки
charAt() - возвращает символ строки по индексу
equals() - сравнивает строки с учетом регистра
equalsIgnoreCase() - сравнивает строки без учета регистра
indexOf() - находит индекс первого вхождения подстроки в строку
lastIndexOf() - находит индекс последнего вхождения подстроки в строку
startsWith() - определяет, начинается ли строка с подстроки
endsWith() - определяет, заканчивается ли строка на определенную подстроку
replace() - заменяет в строке одну подстроку на другую
trim() - удаляет начальные и конечные пробелы
substring() - возвращает подстроку, начиная с определенного индекса до конца или до определенного индекса
toLowerCase() - переводит все символы строки в нижний регистр
toUpperCase() - переводит все символы строки в верхний регистр


### 2. Public, private. Getters & Setters

Права доступа к свойствам и методам — это на первый взгляд всего лишь слова: private и public.
Но что скрывается за ними? Какие преимущества это дает в разработке? И как их правильно использовать?

В Java, модификаторы доступа `public`, `default` (также известный как "package-private"), и `private` контролируют, где и как классы, методы, и переменные могут быть доступны для использования. 
Это часть концепции инкапсуляции в объектно-ориентированном программировании.

## 1. Модификаторы доступа
- **Public**: Элементы с этим модификатором доступны в любом месте программы, в том числе и в других пакетах.
  Public — публичный. Классы и методы, объявленные public, могут быть доступны как внутри самого класса,
  так и в объектах, реализовавших класс.
- 
- **Default (Package-Private)**: Если модификатор доступа не указан, он по умолчанию становится "default". 
- Такие элементы доступны только в пределах своего пакета.

- **Private**: Элементы с этим модификатором доступны только в пределах того класса, в котором они объявлены.
  Private — объявляет метод или свойство доступным только в том классе в котором он присутствует.
  То есть к private методам и свойствам мы не можем обращаться ни из других объектов, ни из дочерних классов.

## 2. Getters и Setters
`Getters` и `Setters` - это методы, которые позволяют безопасно получать и устанавливать значения приватных переменных класса.

## Зачем нужны Getters и Setters:
- **Инкапсуляция**: Они обеспечивают контролируемый доступ к данным класса. Путем использования этих методов можно предотвратить непосредственный доступ к полям класса, что повышает безопасность и гибкость.

- **Валидация данных**: В сеттерах можно реализовать логику проверки данных перед их установкой. Это помогает поддерживать объект в валидном состоянии.

- **Абстракция**: Используя геттеры и сеттеры, детали реализации класса скрыты от пользователя, что делает код более читаемым и удобным для поддержки.

- **Гибкость**: Можно изменить логику получения или установки значения без изменения интерфейса класса.

## Примеры в коде Java

```java
public class MyClass {
    private int myField; // Приватное поле

    // Getter для myField
    public int getMyField() {
        return myField;
    }

    // Setter для myField
    public void setMyField(int myField) {
        this.myField = myField;
    }
}
```

В этом примере `myField` является приватным, так что к нему нельзя получить прямой доступ извне класса `MyClass`. Однако мы можем использовать `getMyField` и `setMyField` для чтения и изменения значения `myField` соответственно, обеспечивая при этом инкапсуляцию и возможную валидацию данных.


### 3. Random: Math.random() и Random
   Генерация случайных чисел в Java - важная и нужная тема. Действительно, она Вам понадобится неисчислимое количество раз.

Например:

    при заполнении массива случайными числами
    при перетасовке колоды карт
    при выборе случайного элемента из последовательности
    и т.д.

Существует несколько способов как сгенерировать случайное число.
В библиотеке классов Java есть пакет java.lang, у которого есть класс Math, а у класса Math есть метод  
# random().

Так вот, при каждом вызове Math.random() c помощью специального алгоритма (за определенной инструкцией) генерируется случайное число. 
Можно ли предсказать какое число будет сгенерировано? Теоретически это возможно, но это очень трудно сделать. 
А поскольку все-таки существует небольшая вероятность предсказать, какое же число будет сгенерировано алгоритмом, 
такие числа принято называть не случайными, а псевдослучайными.

По умолчанию Math.random() генерирует случайные вещественные числа из промежутка [0;1), то есть от нуля включительно до 1 исключительно,
то есть, от 0 (включительно) до 1 (но не включая 1), которое затем можно отмасштабировать до нужного диапазона. 
При необходимости с использованием округления можно получить псевдослучайное целое число.
Реализация сама выбирает начальное зерно для алгоритма генерации случайных чисел; оно не может быть выбрано или сброшено пользователем.

# Класс Random 


В Java есть специальный класс Random. 
Это очень интересный класс, и у него есть много интересных методов. 
Начнем с самых простых:

Метод double nextDouble() - Этот метод возвращает случайное вещественное число в диапазоне 0.0 – 1.0. Очень похоже на метод Math.random(). И ничего удивительного, ведь метод Math.random() просто вызывает метод nextDouble() у объекта типа Random.

Метод float nextFloat() - Метод очень похож на метод nextDouble(), только возвращаемое случайное число типа float. Оно также лежит в диапазоне 0.0 – 1.0. И, как всегда, в Java диапазон не включает число 1.0.

Метод int nextInt(int max) - Этот метод возвращает случайное целое число в диапазоне [0, max). 0 входит в диапазон, max — не входит.

Т.е. если вы хотите получить случайное число из набора 1, 2, 3, 4, 5, 6, вам нужно будет прибавить к полученному случайному числу единицу:

Метод int nextInt() - Этот метод аналогичен предыдущему, но не принимает никаких параметров. Тогда в каком же диапазоне он выдает числа? От -2 миллиарда до +2 миллиарда.

Ну или если точнее, от -2147483648 до +2147483647.

Посмотрите какие еще методы вы можете найти у этого класса.


### 4. Scanner - ввод данных с клавиатуры
   ava Scanner Class
   Первое и главное, с чем нам нужно познакомиться, — класс java.util.Scanner.

Его функциональность очень проста. Он, словно настоящий сканер, считывает данные из источника, который мы для него указываем. 
Например, из консоли ( или из строки, из файла). Далее он распознает эту информацию и обрабатывает нужным образом.

```java 
public class Main {

   public static void main(String[] args) {

      Scanner sc = new Scanner(System.in);
      System.out.println("Введите число:");

      int number = sc.nextInt();

      System.out.println("Спасибо! Вы ввели число " + number);

   }
}

```

Метод nextInt() считывает и возвращает введенное число. В нашей программе он используется для того, чтобы присвоить значение переменной number.

Но у нас осталась одна серьезная проблема. Пользователь может ошибиться и ввести что-то не то.

Вот пример, когда наша текущая программа перестанет работать:

```java 

public class Main {

public static void main(String[] args) {

       Scanner sc = new Scanner(System.in);
       System.out.println("Введите число:");

       int number = sc.nextInt();

       System.out.println("Спасибо! Вы ввели число " + number);

}
}
```


Попробуем ввести вместо числа строку “Java”:

Вывод в консоль:

```java 
Введите число:
Java

Exception in thread "main" java.util.InputMismatchException
```

Во избежание подобных ситуаций нам нужно придумать способ проверки данных, которые вводит пользователь. 
Например, пользователь вводит что угодно, кроме числа, хорошо бы вывести в консоль предупреждение, 
что введенная информация не является числом, а если все в порядке — вывести текст подтверждения.

Но для этого нам надо фактически “заглянуть в будущее” — узнать, что там дальше в нашем потоке. 
Scanner в Java умеет это делать и для этого у него есть целая группа методов:

hasNextInt() — метод проверяет, является ли следующая порция введенных данных числом, или нет (возвращает, соответственно, true или false).

hasNextLine() — проверяет, является ли следующая порция данных строкой.

hasNextByte(), hasNextShort(), hasNextLong(), hasNextFloat(), hasNextDouble() — все эти методы делают то же для остальных типов данных.

Но пользоваться этими методами мы научимся когда изучим условные операторы.

Есть еще один метод, на который нужно обязательно обратить внимание — close(). 
Как и любой объект, работающий с потоками ввода-вывода, сканер должен быть закрыт по завершении своей работы, 
чтобы больше не потреблять ресурсы нашего компьютера.

Никогда не забывай о методе close()!

